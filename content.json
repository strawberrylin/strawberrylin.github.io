[{"title":"Hello World","date":"2080-12-30T16:00:00.000Z","path":"2080/12/31/start/","text":"Welcom to strawberylin’s home. This is my very first post. If you find any problems or trouble you can find me on GitHub. Review 2014年，进入大学，开始有关计算机科学的学习，出于兴趣，2015年开始搭建个人博客。开始是借助github,后来了解到Hexo,但是每次都是玩一玩，没有花时间去管理和更新，导致之前的博客内容琐碎杂乱。 大学时光已近3/4，说到收获却无从说起，似乎什么收获都没有．于是决定培养一个写博客的习惯，将学到的一点一点收起来,同时将前面的blog重新整理和更新． Sum水滴石穿","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wlins.me/tags/随笔/"},{"name":"hexo","slug":"hexo","permalink":"http://wlins.me/tags/hexo/"}]},{"title":"Spring-Boot","date":"2018-03-25T16:00:00.000Z","path":"2018/03/26/SpringBoot/","text":"SpringBoot简介SpringBoot是SpringMVC的升级版，有如下特点： 配置简单 新一代框架 微服务入门级框架 IDEA创建SpringBoot程序Spring Initializer –&gt; Write the detail –&gt;Web + Thymeleaf + MySQL + JDBC –&gt; Create Project. main/java文件目录:编写的类(控制器) main/source文件目录:属性配置 test文件目录:单元测试文件目录 运行项目 Step1. idea里面直接运行类 Step2. 进入项目根目录，执行 1mvn spring-boot:run Step3. 首先编译执行 1mvn install 然后进入target目录下，执行 1java -jar *.jar 编写Controller 新建java类，标签＠RestController 方法标签@RequestMapping(value = “/test”, methos = RequestMethod.Get) 12345678@RestController public class Hello &#123; @RequestMapping(value = \"/hello\", method = RequestMethod.GET) public String print()&#123; return \"Hello\"; &#125; &#125; 编写配置文件在application.properties文件下配置端口,url等信息在配置文件中添加一个变量，然后在类文件中使用标签@Value(“${变量名}”)来关联一个变量，将配置为呢间中的属性诸如到变量中． size=B 12@Value(\"$&#123;size&#125;\") private String size; 然后可以直接使用 1return size 此时直接获取了size的值为B同时属性可以嵌套，就是在新的属性里使用之前设置的属性，比如 1content: \"$&#123;size&#125;\" 对于每一个属性，使用时都需要通过@Value标签来使用，这样带来了很大的冗余性的工作，比较好的方式是编写一个类，然后将属性的值映射到类，然后通过类实例化一个对象，直接使用． Step1. 在application.properties下编写响应的配置文件，将所有属性写在同一个前缀下 12345678910111213141516171819202122232425test.size=1 test.name=A``* Step2. 编写一个相对应的类，添加相应的标签注释，就可以自动将属性映射到类的成员``` java@Component @ConfigurationProperties(prefix = \"test\") public class TestProperties &#123; private String name; private int size; public String getName() &#123; return name; &#125; public int getSize() &#123; return size; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setSize(int size) &#123; this.size = size; &#125; &#125; Step3. 使用时添加@AutoWired标签映射，然后后定义一个相应类型的变量，直接通过get方法來获取对应属性的值 1234567@Autowired private TestProperties tp ; @RequestMapping(value = \"/hello\", method = RequestMethod.GET) public String print()&#123; return tp.getName(); &#125; 可以新建多个配置文件，然后在默认的配置文件中通过spring.profiles.active=””來设置使用哪个配置文件. Controller使用控制器接收请求并处理 @Controller 处理http请求 @RestController Spring4新加的注解 @RequestMapping 配置url映射，通过url可以访问到我们写的方法 这里我们有两种设计方式，方式１．使用Restful风格，则使用@RestController标签，然后只用返回相应的值或者资源方式2. 使用模板，比如thymeleaf模板，则使用@Controller标签，在resources/templates/下新建html文件然后在方法返回相应的html文件． url中参数的解析 @PathVariable 获取url中的数据 123@RequestMapping(value = \"/hello/&#123;id&#125;\", method = RequestMethod.GET) public String print(@PathVariable(\"id\") int id)&#123; return tp.getName() + id; 在url中直接加入要传递的参数值即可，Eg: /test/100 @RequestParam 获取请求参数的值1234@RequestMapping(value = \"/hello\", method = RequestMethod.GET) public String print(@RequestParam(\"id\") int id)&#123; return tp.getName() + id; &#125; 在url中直接加入?id=，Eg: /test?id=100，可以设置默认值 @GetMapping 组合注解，还包括@PostMapping,@PutMapping等，主要是简化代码，少写代码． 数据库操作-MySQLJPA： 定义了一系列对象持久化的标准，是一种规范通过配置文件來配置数据库的驱动和JPA，在配置文件中添加依赖1234 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; 然后在属性文件中编辑数据库的配置信息1234567spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test spring.datasource.username=root spring.datasource.password=123456 spring.jpa.hibernate.ddl-auto=update spring.jpa.show-sql=true Tips:create每次运行时都会删除旧的表然后新建一张新表update每次更新，不会ｉ删除原表 此时我们可以选择自己去数据库创建数据表，也可以采用映射的方式自动添加数据表Step1. 首先创建一个类，添加空的构造方法以及get和set方法Step2. 添加注释@Entity，@Id主键，@GeneratedValue生成值1234567891011121314151617181920212223242526272829303132333435 @Entity public class Person &#123; @Id @GeneratedValue(strategy= GenerationType.IDENTITY) private int id; private String size; private int age; public Person() &#123; &#125; public int getId() &#123; return id; &#125; public String getSize() &#123; return size; &#125; public int getAge() &#123; return age; &#125; public void setId(int id) &#123; this.id = id; &#125; public void setSize(String size) &#123; this.size = size; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 添加(strategy= GenerationType.IDENTITY)来确保自增然后运行，即可在数据库下生成一张和类名相同的表`` ### 编写API采用Restful风格设计，编写所有的接口，包括创建，获取，查询等接口主要是编写对应的Controller 首先编写一个接口继承JapRepository 12public interface PersonRepository extends JpaRepository&lt;Person, Integer&gt;&#123; &#125; 编写对应的Controller 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@RestController public class PersonController &#123; @Autowired private PersonRepository personRepository; @GetMapping(value = \"/persons\") public List&lt;Person&gt; personList()&#123; /* \\* @param \\* @Description: 查询列表 \\* @Date: 上午8:46 18-3-26 */ return personRepository.findAll(); &#125; @PostMapping(value = \"/persons\") public Person addPerson(@RequestParam(\"size\") String size, @RequestParam(\"age\") Integer age)&#123; /* \\* @param size \b \\* @param age \\* @Description: Add a person \\* @Date: 上午11:14 18-3-26 */ Person person = new Person(); person.setSize(size); person.setAge(age); return personRepository.save(person); &#125; @GetMapping(value = \"/persons/&#123;id&#125;\") public Optional personFindOne(@PathVariable(\"id\") Integer id)&#123; /* \\* @param id \\* @Description: 两种方式可选 注册，返回类是Optional&lt;Girl&gt;， Optional是jdk8自带的 \\ \\* @GetMapping(value = \"/girls/&#123;id&#125;\")\\ \\* public Optional&lt;Girl&gt; girlFindOne(@PathVariable(\"id\") Integer id) &#123;\\ \\* //直接用findById查找 \\ \\* //return girlRepository.findById(id); \\ \\* //构通Example查找 \\ \\* Girl girl = new Girl(); \\ \\* girl.setId(id); \\ \\* Example&lt;Girl&gt; example = Example.of(girl); \\ \\* return girlRepository.findOne(example); \\ \\* @Date: 下午7:39 18-3-26 */ return personRepository.findById(id); &#125; @PutMapping(value = \"/persons/&#123;id&#125;\") public Person personUpdate(@PathVariable(\"id\") Integer id, @RequestParam(\"age\") Integer age, @RequestParam(\"size\") String size)&#123; /* \\* @param id \\* @param age \\* @param size \\* @Description: save接口根据数据库中的主键来更新,使用Put方式时,Postman要使用x-www-form-urlencode的数据格式 \\* @Date: 下午7:55 18-3-26 */ Person person = new Person(); person.setId(id); person.setAge(age); person.setSize(size); return personRepository.save(person); &#125; @DeleteMapping(value = \"/persons/&#123;id&#125;\") public void personDelete(@PathVariable(\"id\") Integer id)&#123; /* \\* @param id \\* @Description: \\* @Date: 下午8:04 18-3-26 */ personRepository.deleteById(id); &#125; &#125; 如果要扩展查询，比如多种查询参数和方式，则需要扩展personRepository接口，比如通过年龄来查找 首先要扩展personRepository 123public interface PersonRepository extends JpaRepository&lt;Person, Integer&gt;&#123; public List&lt;Person&gt; findByAge(Integer age); &#125; 然后编写对应的COntroller 1234@GetMapping(value = \"persons/age/&#123;age&#125;\") public List&lt;Person&gt; personListByAge(@PathVariable(\"age\") Integer age)&#123; return personRepository.findByAge(age); &#125; ### 数据库事务管理 事务管理是对于一些列操作要么都执行，要么都不执行，在电商平台最常见，下单，付款，发货设计对数据库的的操作要一致，主要是维护数据库的安全性．通过＠Transactional注释来进行事务管理，在操作方法前添加此标签，则方法里的事务要么全部执行，要么都不执行．","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wlins.me/tags/随笔/"},{"name":"Spring-Boot","slug":"Spring-Boot","permalink":"http://wlins.me/tags/Spring-Boot/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://wlins.me/tags/JavaWeb/"}]},{"title":"SpringMVC","date":"2018-03-18T16:00:00.000Z","path":"2018/03/19/SpringMVC/","text":"SpringMVC简介一种开发Web应用的通用架构方式，用户端的请求通过http到达前端控制器(Front Controller)，他了解这个请求应该被谁处理，然后将请求代理给了具体的控制器(Controller)，控制器了解业务逻辑的细节，因此调用相关业务逻辑生成业务数据，并将数据返回给前端控制器，前端控制器将业务数据分发给业务视图(View template)，由业务视图来呈现最终的用户界面，并将用户界面返回给前端控制器，并最终将页面返回给浏览器端．MVC核心思想是将业务数据抽取和业务数据呈现相分离． SpringMVC基本概念 前端控制器：分发调度 控制器：业务数据抽取 业务视图：页面呈现 View：网页界面 Model：业务实体，一般编写的类，业务数据的信息表示，通常是多个业务实体的组合 Controller：调用业务逻辑产生合适数据生成model并传递给Model层 DispatcherServlet：Spring的前端控制器，进行业务分发，传递数据 Handler：是DispatcherServlet内部使用的一个类，是Controller的一种表现形式 HandlerAdapt：Handler适配器，将各种不同类型的类适配成DispatcherServlet能够使用的类 HandlerInterceptor：拦截器接口，实现后可以在调用控制器之前或者之后做很多事情 HandlerMapping：前端控制器与Contller之间的映射，确定DispatcherServlet获得正确的Controller HandlerEcutionChain：HandlerAdapter．HandlerInterceptor和HandlerMapping构成一条链，执行preHandle,Controller Method,postHandle,AfterCompletion． ViewResolver：视图解析器，告诉你应该具体用哪个视图来进行视图解析． 其实主要工作在于编写Controller中的代码，根据业务逻辑來编写代码． MAVEN项目搭建架构管理工具 POM：编写一个xml文件，比如pom.xml，配置文件，在其中维护很多信息，比如一些依赖，生命周期，插件 Dependency Management：一个项目可能会依赖其他很多东西，开发的时候就必须添加很多所依赖的java包，JavaWeb项目一般放在/WEB_INF/lib下．通过Maven可以通过自动管理，只需要在POM文件中编写相关依赖，在标签下． Coordinates：坐标，Maven类似一个仓库，其他软件商会向其中添加软件，然后哦我们可以通过坐标来寻找和使用．包括groupId，artifactId，version，packaging四个属性构成唯一标志，（自己新建项目是GroupId一般填写Java目录的组织结构，eg: me.wlins，artifiactId一般是项目名）. 项目开发通过Maven新建项目 配置文件1. pom.xml文件: 添加变量&lt; properties >，设置所用到的软件版本，方便管理 123&lt;properties&gt; &lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; 配置&lt; dependences >，配置依赖管理，添加&lt; dependencyManagement > 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--日志--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.21&lt;/version&gt; &lt;/dependency&gt; &lt;!--J2EE--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;jstl-impl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--mysql驱动包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;/dependency&gt; &lt;!--springframework--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.stefanbirkner&lt;/groupId&gt; &lt;artifactId&gt;system-rules&lt;/artifactId&gt; &lt;version&gt;1.16.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--其他需要的包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 添加框架支持右击我们的项目文件夹，选择add framework support，然后在窗口中分别选中spring和springmvc，并且选择spring是，记得勾选create empty springconfig.xml，点击ok之后，我们会发现WEB-INF文件夹下多出了两个文件(applicationContext.xml,mvc-dispatcher-servlet.xml)，后面会用到． 2. 完善文件目录首先我们在src/main文件夹下创建java文件夹，在WEB-INF下创建statics,view,jsp文件夹，在statics下创建css,image,js文件夹，然后我们进入project structure选择文件夹的作用，在界面的右上角进入project structure，然后在module中选择设置各个模块，其中java文件夹是 sources，test是Test，改完之后，点ok，文件夹会变色，那就成功了。然后再在java文件夹中添加需要的包． 3. web.xml文件 替换头部设置如下來支持更多功能123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app\\_3\\_1.xsd\" version=\"3.1\"&gt; 配置springmvc,创建一个前端控制器12345678910111213141516171819202122232425&lt;!--配置springmvc DispatcherServlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--配置dispatcher.xml作为mvc的配置文件--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/mvc-dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--把applicationContext.xml加入到配置文件中--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; mvc-dispatcher-servlet.xml这个文件负责mvc的配置，配置如下：12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--此文件负责整个mvc中的配置--&gt; &lt;!--启用spring的一些annotation --&gt; &lt;context:annotation-config/&gt; &lt;!\\-\\- 配置注解驱动 可以将request参数与绑定到controller参数上 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!--静态资源映射--&gt; &lt;!--本项目把静态资源放在了webapp的statics目录下，资源映射如下--&gt; &lt;mvc:resources mapping=\"/css/**\" location=\"/WEB-INF/statics/css/\"/&gt; &lt;mvc:resources mapping=\"/js/**\" location=\"/WEB-INF/statics/js/\"/&gt; &lt;mvc:resources mapping=\"/image/**\" location=\"/WEB-INF/statics/image/\"/&gt; &lt;!\\-\\- 对模型视图名称的解析，即在模型视图名称添加前后缀(如果最后一个还是表示文件夹,则最后的斜杠不要漏了) 使用JSP--&gt; &lt;!\\-\\- 默认的视图解析器 在上边的解析错误时使用 (默认使用html)- --&gt; &lt;bean id=\"defaultViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/view/\"/&gt;&lt;!--设置JSP文件的目录位置--&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;property name=\"exposeContextBeansAsAttributes\" value=\"true\"/&gt; &lt;/bean&gt; &lt;!\\-\\- 自动扫描装配 --&gt; &lt;context:component-scan base-package=\"me.wlins.controller\"/&gt; &lt;/beans&gt; applicationContext.xml这个文件主要负责一些非mvc组件（或者其他组件）的配置，配置如下：1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:component-scan base-package=\"me.wlins\"/&gt; &lt;/beans&gt; 编写Controller编写IndexController代码如下：12345678910111213package me.wlins.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping; @Controller @RequestMapping(\"/home\") public class IndexController &#123; @RequestMapping(\"/index\") public String index()&#123; return \"index\"; &#125; &#125; view下编写jsp文件编写index.jsp文件如下：1234567891011121314&lt;%@ taglib prefix=\"c\" uri=\"http://www.springframework.org/tags\" %&gt; &lt;%-- Created by IntelliJ IDEA. User: strawberrylin Date: 18-3-19 Time: 下午1:35 To change this template use File | Settings | File Templates.--%&gt; &lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Index&lt;/title&gt; &lt;link rel=\"stylesheet\" style=\"text/css\" href=\"&lt;c:url value=\"/css/test.css\"/&gt; \"&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Hello SpringMVC!&lt;/h2&gt; &lt;/body&gt; &lt;/html&gt; css下编写样式表编写test.css文件如下：12345h2&#123; background-color: aliceblue; font-family: \"AR PL UKai CN\"; font-size: large; &#125; 然后配置服务器，部署运行即可．访问地址为http://localhost:8080/Hello/home/index (部署时选择的context为Hello，Controller里面访问映射的是/home/index). ```","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wlins.me/tags/随笔/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://wlins.me/tags/JavaWeb/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://wlins.me/tags/SpringMVC/"},{"name":"Maven","slug":"Maven","permalink":"http://wlins.me/tags/Maven/"}]},{"title":"AndroidTestTool-BasedOnMonkeyTest","date":"2018-01-26T16:00:00.000Z","path":"2018/01/27/monkey_test/","text":"一个小工具,python Introduction一个基于monkeytest工具的自动化android测试工具，根据得到的日志文件进行分析，对crash截图保存，并且将crash以表格保存，包括crash类型，时间以及Seed值． Environment linux python3 adb sdk Usage修改mongkey.ini文件，修改其中的包名为待测试的包名，同时可以修改activity值如果修改，在MonkeyConfig.py文件中修改1# app[\"activity\"] = config['DEFAULT']['activity'] 去掉注释用的’#’． 打开模拟器或者链接USB设备，运行main.py开始测试 1# python3 main.py 等待测试结束后，在./log 文件夹下会生成monkey.log和traces.log以及截图文件monkey_log.png，在./目录下生成表格report.xlsx 测试截图 项目地址: https://github.com/strawberrylin/MonkeyTest","tags":[{"name":"linux - python - android - monkeytest","slug":"linux-python-android-monkeytest","permalink":"http://wlins.me/tags/linux-python-android-monkeytest/"}]},{"title":"ME.WLINS.UTIL &nbsp; &nbsp; java package document","date":"2018-01-05T16:00:00.000Z","path":"2018/01/06/me.wlins.util.md/","text":"A personal code repository for java, concret introduction as follows: Print print(); 输出换行 print(obj); 输出然后换行 printnb(obj);输出然后不换行 printf(format,args);Ｃ语言的printf函数 usage : import static me.wlins.util.Print.*; Range range(n); 产生０～n-1 的数组序列 range(start,end);产生start~-end-1的数组序列 range(start,end,step);产生start~end-1,间隔为step的数组序列 usage : import static me.wlins.util.Range.*; MyStack push(); 进栈 pop(); 出栈 peek(); 取栈首元素 empty();判断是否为空栈 usage: Stack stack = new Stack(); //T为初始化类型参数 Hex将二进制文件转化为十六进制输出 format(byte[] data) 静态方法，返回一个十六进制字符串 usage:\\ import me.wlins.util.Hex;\\Hex.format(data); Tuple创建元组，包括二维，三维，四维，五维元组类：TwoTuple, ThreeTuple, FourTuple, FiveTuple usage: 返回多个对象，存在一个元组 \\return new FourTuple(new class1(), new class2(), new class3(), new class4()); PPrint一个灵巧的打印机，一个可以添加新行并且缩排所有元素的工具 String pformat(Collection&lt;?&gt; c); 格式化 void pprint(Collection&lt;?&gt; c); 打印 void pprint(Object[] c); 打印 usage:\\得到一个重排的字符串：PPrint.pformat(list);打印：PPrint.pprint(list); Directory产生由本地文件构成的对象数组，或者产生由给定目录下的有整个目录树中所有文件构成的List\\ File[] local(path, regex);+ walk();参数文件起始路径和正则表达式 &gt; usage:\\ walk();参数文件起始路径和正则表达式 &gt; usage:\\ BinaryFile打开二进制文件，并返回一个byte[] read(File bfile); 打开二进制文件 read(String bfile); 打开二进制文件 usage:\\BinaryFile.read(“filename”);\\BinaryFile.read(new File(filePath); TextFile读写文件，对文件进行分割 read(filename); 读取文件保存到字符串 write(aimfile,source); 将源写入目的文件 构造器TextFile(filename, regex);Textfile(filename);有规则就按照规则分割，没有规则默认换行符 usage;\\TextFile.read(“test.java”)’\\TextFile.write(“test1.java”, file);\\TreeSet\\ words = new TextFile(filename, “\\W+); Click here to visit the github repository","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wlins.me/tags/随笔/"},{"name":"java - doc - introduction","slug":"java-doc-introduction","permalink":"http://wlins.me/tags/java-doc-introduction/"}]},{"title":"Alien War","date":"2017-12-29T16:00:00.000Z","path":"2017/12/30/alien_war/","text":"Project Aim IntroductionI want to lenarn the Python by myself. After I read the &lt;&lt; Python Crash course A hands-on ,Project-based Introduction to Programming &gt;&gt;, I want to strengthen my skill by the project.Click here to visit my Github repository Project Background IntroductionAfter I read the &lt;&lt; Python Crash course A hands-on , Project-based Introduction to Programming &gt;&gt;, there is a project in the book named Alien War, a 2-dimension game written with python using pygame. A suitable project that will help me to master the language, I think.So I spend one hour every day to write the source code in the direction of the book, wantting to master the language better and increase the experience in prgramming through the project. Project Design IntroductionFunction Description :A space ship will stay at the bottom of the screen, only allowed to move rightwards or leftwards which is in the contorl of the payers. A group of aliens will move downwards from the top of the screen, moving rightwards or leftwards. Players are allowed to shot at the aliens. When bullets hit the alien, the alien will be killed and disappear from the screen. After killing all the aliens, there will come another group of aliens. Player will attain the score after every kill and level up while the alens be cleaned every time. If there is an alien hit the space or the bottom of the screen, Players will lose a space ship. Every player has three space ships. Game will over when there is no ship remains. The frequence of the aliens will increase with the level upping and the point of every kill will also increase. Players are requested to get as higher score as they can by their efforts. Module:alien_invasion:The entrance of the game, call other modules. Initialize the game and build the initial run environment of the game.setting:The whole setings of the game, include ship, aliens, bullets, screen, speed, points.game_function:This module includes many functions run in the game to deal with many events. Such as keyboard down events, update events, create events, hit events, calculate events.alien:This module is about the description of the alien.ship:This module is about the dsescripton of the ship.bullet:This module is about the description of the bullet.button:This module is about the description of the button, to create a button of starting game.game_state:To manage the state of the game.score_board:This module will show the score atthe screen. Project Implement Introductionalien_invasion: Import modules: settings, ship, game_states, button, scoreboard. The entrance of the game, there is only one function named as run_game(). Initialize the game and create the screen through pygame. Then create the button, score_board, ship, aliens, bullets, game_states instance. After that, there is a loop can only be ended by the exit() function. Check the keyboard down events, update the alien, ship, bullet and the screen.source code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/usr/bin/env python# coding=utf-8import sysimport pygamefrom settings import Settingsfrom ship import Shipfrom pygame.sprite import Groupfrom game_states import Game_statesfrom button import Buttonfrom scoreboard import Scoreboardimport game_functions as gamefdef run_game(): # initialize the game and build a screen object pygame.init() ai_settings = Settings() screen = pygame.display.set_mode((ai_settings.screen_width,ai_settings.screen_height)) pygame.display.set_caption(\"Alien War\") # create a button play_button = Button(ai_settings, screen, \"Play\") # create a intence of Game_states games = Game_states(ai_settings) # create the score board score_board = Scoreboard(ai_settings, screen, games) # set the background screen.fill(ai_settings.bg_color) # create a ship ship = Ship(ai_settings,screen) # create a group to store the bullets bullets = Group() # create a group to store te aliens aliens = Group() if games.game_active == 1: gamef.create_fleet(ai_settings,screen,ship,aliens) # start the main loop while True: # watch the mouse and keyboard gamef.check_events(ai_settings,screen,games,score_board,play_button,ship,aliens,bullets) if games.game_active == 1: # update the locating ship.update() # update the bullets gamef.update_bullet(ai_settings,screen,games,score_board,ship,aliens,bullets) # update the aliens gamef.update_alien(ai_settings,games,screen,score_board,ship,aliens,bullets) # update the screen gamef.update_screen(ai_settings,screen,games,score_board,ship,aliens,bullets,play_button) run_game() game_function: Define a largr of functions in the game. The function manu is as follows: check_keydown_events(event,ai_settings,screen,ship,bullets): deal with keydown eventcheck_keyup_events(event,ship): deal with keyupcheck_events(ai_settings,screen,states,score_board,play_button,ship,aliens,bullets): react to the mouse and keyboardupdate_screen(ai_settings,screen,states,score_board,ship,aliens,bullets,play_button): update the screenupdate_bullet(ai_settings,screen,states,score_board,ship,aliens,bullets): update the bullet and delete the old bulletsupdate_alien(ai_settings,states,screen,score_board,ship,aliens,bullets): check the site of the alien and update the site of the every alienget_number_aliens_x(ai_settings,alien_width): calculate how many a line a line can containget_number_rows(ai_settings,ship_height,alien_height): calculate how many aliens the screen can containcreate_alien(ai_settings,screen,aliens,alien_number,alien_rows): create an aliencreate_fleet(ai_settings,screen,ship,aliens): create the group of the alienscheck_fleet_edges(ai_settings,aliens): what if the aliens hit the edgeschange_fleet_direction(ai_settings,aliens): change the direction of the aliencheck_collide_bullet_alien(ai_settings,screen,states,score_board,ship,aliens,bullets): react to the hit between aliens and bulletsship_hit(ai_settings,states,screen,score_board,ship,aliens,bullets): react to the hit between ship and alienscheck_aliens_bottom(ai_settings,states,screen,score_board,ship,aliens,bullets): check if aliens arrive at the bottom of te screencheck_play_button(ai_settings,screen,states,score_board,play_button,ship,aliens,bullets,mouse_x,mouse_y): start the ame when click at the buttoncheck_highest_score(states, score_board): check if there is new score and update the score setting: Define the variable in the game and initialize the game, include: screen, bullet, alien, ship, speed.alien: Extends from Sprite, Initialize the alien and define the behavor of the alien: update, check edges.ship: Extends from Sprte, initialize the ship and define the behavor of the ship: update.bullet: Extends fom Sprite, initialize the bullet and define the behavor of the bullet: update, draw_rect.button: Define a button, render the “play” to an image and draw the button.game_state: Initialize the game’s state, add the reset behavor.score_board: Initialize the score board, render the score, level, highest score to an image and dislay the elft ship at he score. Project SummaryI spend one hour every dey almost half the month to write the project in the direction of the book, there are almost the whole source code in the book. I just fix some problems where I think exist some question in the logic. And I also add a start page to beauty the game. Above all, my skill in python has been promoted through the project.","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wlins.me/tags/随笔/"},{"name":"python - game","slug":"python-game","permalink":"http://wlins.me/tags/python-game/"}]},{"title":"Machine-Learning-Caffe","date":"2017-07-04T16:00:00.000Z","path":"2017/07/05/caffe-learn/","text":"Caffe是一个深度学习的框架，主要用于神经网络深度学习 Caffe模型 Layers Layer是Caffe模型和计算的基本单元，一系列layer和其他连接的集合组成了Net 每一个Layer都定义了三种运算 setup 在模型初始化时重置layer及其相互的连接 forword 从Bottom层中接收Blob数据，进行计算后输出送入到top层中 backword 给定相对于top层输出的梯度，计算其相对于输入的梯度，并传递到Bottom层 Blobs Caffe使用Blobs结构來存储,交换,处理网络中的数据和导数信息，Blob是标准的数组结构 Nets Caffe基于自己的模型，通过逐层定义Layer的方式定义整个网络，网络从数据输入层到损失层自下向上的定义整个模型 Net::Init() 进行模型的初始化，创建Blobs和Layers，搭建整个无向图，调用layer的Setup函数 前传与后传 前传 Caffe组合每一层的计算以得到整个模型的计算函数 Layer::Forward() 实现每一层的前传 Net::Forward() 实现网络的前传 后传 Caffe反向组合每一层的梯度來计算整个网络的梯度 Layer::Backward() 实现每一层的后传 Net::Backward() 实现网络的后传 Loss学习的目的是找到一个网络权重的集合，使得损失函数最小损失通过网络的前向计算得到，某些层的输出可以作为损失函数 SolverSolver通过协调Net的前向推断计算和反向梯度计算来对参数进行更新,从而达到减小loss的目的","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wlins.me/tags/随笔/"},{"name":"ml-caffe","slug":"ml-caffe","permalink":"http://wlins.me/tags/ml-caffe/"}]},{"title":"Machine-Learning-KNN","date":"2017-07-03T16:00:00.000Z","path":"2017/07/04/knn/","text":"KNN算法KNN算法用来解决分类问题，它是属于基于实例的学习，每一次学习都是根据实例，也属于懒惰学习，处理训练集时没有创建模型，后面根据实例的对比才来归类 为了判断未知实例的类别，通过与他最近的已知实例的类别來对这个未知实例进行分类 选择一个参数K，K是选择已知实例的数目，使预测具有最高的精确度 计算未知实例和所有已知实例的距离 选择最近K个已知实例 选取最邻样本中最多数的类别作为这个实例的类别 KNN算法应用在python库中有iris的数据集，可以直接加载，并且使用数据集分为两部分，第一部分是每一个实例的特征值，有4项，第二部分是实例的标记 1234567891011121314from sklearn import neighborsfrom sklearn import datasetsknn = neighbors.KNeighborsClassifier()iris = datasets.load_iris()print irisknn.fit(iris.data, iris.target)predictedLabel = knn.predict([[0.1, 0.2, 0.3, 0.4]])print (\"predictedLabel is :\" + predictedLabel)print predictedLabel 对于未知实例[0.1,0.2,0.3,0.4]，预测的结果为属于[0]","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wlins.me/tags/随笔/"},{"name":"ml - knn","slug":"ml-knn","permalink":"http://wlins.me/tags/ml-knn/"}]},{"title":"Machine-Learning-DecisionTree","date":"2017-07-02T16:00:00.000Z","path":"2017/07/03/decisiontree/","text":"Decision Tree决策树算法属于监督学习，决策树是一个类似一流程图的树型结构，每个内部结点表示在一个属性上的测试，每个分支代表一个属性输出，每个树叶结点代表类或者类分布，树的最顶层是根结点。 每个结点进行一个属性的检测 每个分支代表属性的一个可能取值，分支到不同结点 每个结点有关于类别的分布 构造决策树的算法熵(entropy)对于不确定的事件，通过信息量來度量，越不确定一件事，需要的信息量越大 熵计算公式如下: 决策树归纳算法(ID3)构造决策树时怎么选择结点，用于选择属性判断结点。通过变量值信息获取量(Information Gain)來判断，一个属性的信息获取量计算：Gain(A) = Info(D) - Info_A(D)即没有A时的信息量减去加上A之后的信息量，差值作为判断标准(D是数据集,A是属性)，步骤如下： 1 计算事件总的熵 2 针对每一个属性进行划分，然后计算划分的每一个熵 3 利用信息量获取计算公式计算出每个属性的信息获取量 4 选择最大的信息量的结点 5 剩下的节点进行重复计算","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wlins.me/tags/随笔/"},{"name":"ml - decisiontree","slug":"ml-decisiontree","permalink":"http://wlins.me/tags/ml-decisiontree/"}]},{"title":"Machine-Learning-BaseConception","date":"2017-06-29T16:00:00.000Z","path":"2017/06/30/concept_day1/","text":"本文主要介绍一些浅显的机器学习的基本概念 概念学习 从某个有关布尔函数的输入和输出训练样例中该推断出该布尔函数 实例与集合 实例是一个样例，所有的实例构成一个集合 目标概念 待学习的函数或者目标概念 训练集 训练样例，用来进行训练，也就是产生模型或者算法的数据集 测试集 测试样例，用来专门进行测试已经学习好的模型或者算法的数据集 特征向量 属性的集合，通常用一个向量来表示，附属于一个实例 标记 实例类别的标记，学习的答案，结果的可能值的集合 分类与回归 分类: 目标标记为类别型数据回归: 目标标记为连续型数据 监督学习 有监督学习: 训练集有类别标记无监督学习: 训练集无类别标记半监督学习: 有类别标记的训练集+无标记的训练集 机器学习步骤与框架 把数据拆分为训练集和测试集 用训练集和训练集的特征向量來训练算法 把学习來的算法运用在测试集上评估算法 end有关机器学习的一些基本概念介绍完毕，有什么问题可以联系我Blog or Github.","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wlins.me/tags/随笔/"},{"name":"ml - conception","slug":"ml-conception","permalink":"http://wlins.me/tags/ml-conception/"}]},{"title":"Hexo-Github-Blog","date":"2017-03-12T16:00:00.000Z","path":"2017/03/13/blog/","text":"本次博客是借助Hexo + Github搭建，需要用到Nodejs和npm，主机系统是Ubuntu 16.04 LTS。 preparationNodejs &amp; npm 安装Nodejs &amp; npm，用于生成静态页面和安装插件，Nodejs必须是6.x版本 Github首先安装git工具1sudo apt-get install git 部署时需要通过git工具将本地文件提交到远程github仓库 然后到Github官网注册github帐号，在github官网创建仓库，仓库名必须为”your_id”.github.io,(将引号内容替换为你的github名） Hexo在本地创建一个文件夹，进入本文件夹，安装Hexo1sudo npm install -g Hexo procedureblog工程初始化安装1hexo init 操作完成后，文件夹下会生成配置文件生成静态界面1hexo generate 操作完成后，会根据前阶段的文件生成静态页面文件与github关联修改文件夹下的_config.yml文件，在文件尾，修改对应配置1234deploy: type: git repo: https://github.com/your_github_id/your_github_id.github.io.git branch: master 注意，每个冒号后面有一个空格，语法要求，否则报错部署1hexo deploy 需要输入github的账号和密码在浏览器输入地址 https://github.com/your_github_id/your_github_id.io即可访问hex Hello World页面，至此，个人博客搭建成功。 inclusion增加文章blog文章用markdown语法写，保存为md文件，放在/source/_posts路径下即可,然后部署即可123hexo cleanhexo ghexo d 每次部署使用这三条命令 修改主题hexo 的主题放在/theme路径下，在网上找到对应的hexo主题包，放在这个路径下，然后修改_config.yml文件。在__config.yml文件中，有一个theme的配置项，改为你自己的主题名即可1theme: your_theme_name 本地调试在执行完hexo generate命令后，可以进行本地调试，预览blog效果123hexo cleanhexo ghexo server 然后在浏览器地址栏输入localhost:4000,即可预览 Nodejs安装6.x版本问题我在安装Nodejs的过程中，遇到一个问题，我安装的是6.x版本，但实际上装得是4.x版本，通过node -v查看版本，发现版本不对，花了很久才找到解决方法安装Nodejs方法网上很多教程，但是我发现我按装时选择的是最新版本，可实际安装的却是4.2.6版本，解决方法如下： 新建一个文件:/etc/apt/sources.list.d/nodesource.list(需要权限),文件中写入下面两行： 12deb https://deb.nodesource.com/node_6.x xenial maindeb-src https://deb.nodesource.com/node_6.x xenial main 下载GPG Signing Key 1curl -s https://deb.nodesource.com/gpgkey/nodesource.gpg.key | sudo apt-key add - update 1sudo apt-get update 检查apt-cache 1apt-cache policy nodejs 结果应该显示node的新版本，如果没有，则出错，检查前面的步骤 安装nodejs1sudo apt-get install nodejs 查看nodejs 版本1node -v 我经过上面的步骤后成功安装nodejs 6.0版本。 end至此，一个简单的个人博客应该搭建完成，有什么问题可以联系我Blog or Github.","tags":[{"name":"随笔","slug":"随笔","permalink":"http://wlins.me/tags/随笔/"},{"name":"hexo","slug":"hexo","permalink":"http://wlins.me/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://wlins.me/tags/github/"},{"name":"linux","slug":"linux","permalink":"http://wlins.me/tags/linux/"}]}]